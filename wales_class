/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var walespoint = /* color: #0b4a8b */ee.Geometry.Point([-4.06494140625, 53.11710851455023]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

// Load Landsat 5 input imagery.
var landsat1 = ee.Image(ee.ImageCollection('LANDSAT/LC08/C01/T1')
  // Filter to get only one year of images.
  .filterDate('2015-01-01', '2015-06-30')
  // Filter to get only images under the region of interest.
  .filterBounds(walespoint)
  // Sort by scene cloudiness, ascending.
  .sort('CLOUD_COVER')
  // Get the first (least cloudy) scene.
  .first());

// Load Landsat 5 input imagery.
var landsat2 = ee.Image(ee.ImageCollection('LANDSAT/LC08/C01/T1')
  // Filter to get only one year of images.
  .filterDate('2015-07-01', '2015-12-31')
  // Filter to get only images under the region of interest.
  .filterBounds(walespoint)
  // Sort by scene cloudiness, ascending.
  .sort('CLOUD_COVER')
  // Get the first (least cloudy) scene.
  .first());

//var mosaic = landsat.mosaic();

// Compute cloud score.
var cloudScore1 = ee.Algorithms.Landsat.simpleCloudScore(landsat1).select('cloud');
var cloudScore2 = ee.Algorithms.Landsat.simpleCloudScore(landsat2).select('cloud');

// Mask the input for clouds.  Compute the min of the input mask to mask
// pixels where any band is masked.  Combine that with the cloud mask.
var date1 = landsat1.updateMask(landsat1.mask().reduce('min').and(cloudScore1.lte(50)));
var date2 = landsat2.updateMask(landsat2.mask().reduce('min').and(cloudScore2.lte(50)));

// Multi-date composite
var composite = date1.addBands(date2);

// Use MODIS land cover, IGBP classification, for training.
//var modis = ee.Image('MODIS/051/MCD12Q1/2011_01_01')
//    .select('Land_Cover_Type_1');

var trainingraster = ee.Image('users/luiscartor/wales_c35training_NAs');

// Sample the input imagery to get a FeatureCollection of training data.
var training = composite.addBands(trainingraster).sample({
  numPixels: 5000,
  seed: 0
});

// Make a Random Forest classifier and train it.
var classifier = ee.Classifier.randomForest(50)
    .train(training, 'b1');

// Classify the input imagery.
var classified = composite.classify(classifier);

// Define a palette for the IGBP classification.
var igbpPalette = [
  'ff0000', // broadleaved f
  '008000', // evergreen
  '8b4513', // arable
  '7cfc00', // improved
  'FFA500', // 
  '66CDAA', // neutral
  '2E8B57', // calcareous
  '808000', // acid
  'FFFF00', // fen
  '800080', // heather
  'EE82EE', // heather grassland
  '008080', // bog
  '40E0D0', // montaine
  'B0C4DE', // bare rock
  '00008B', // sea
  '0000FF', // water
  'B8860B', // supra
  'B8860B'  // supra
  'FFFFE0'  // litoral
  'FFFFE0'  // litoral
  '9370DB'  // marsh
  '000000'  // urban
  'A9A9A9'  // semi urban
];



Map.centerObject(walespoint, 10);
Map.addLayer(composite, {bands: ['B4', 'B3', 'B2']}, 'landsat');//Map.addLayer(classified, {palette: igbpPalette, min: 0, max: 17}, 'classification');
Map.addLayer(classified, {palette: igbpPalette, min: 0, max: 17}, 'classification');
//Map.addLayer(landsat2);//Map.addLayer(classified, {palette: igbpPalette, min: 0, max: 17}, 'classification');
