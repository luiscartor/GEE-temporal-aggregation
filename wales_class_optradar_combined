/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var S1area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-4.25994873046875, 52.97847790594886],
          [-3.97979736328125, 51.90875993271863],
          [-3.5322682632632905, 51.93943160087239],
          [-3.3887907575058307, 51.968055159146736],
          [-3.28765869140625, 52.125120950434145],
          [-3.07891845703125, 52.908964224129605],
          [-3.47991943359375, 53.00988788760457],
          [-3.73809814453125, 52.980131632468]]]),
    test_area = /* color: #98ff00 */ee.Geometry.Polygon(
        [[[-3.6199951171875, 53.248905518153315],
          [-3.5540771484375, 53.265336258629475],
          [-3.5540771484375, 53.30802665091056],
          [-3.636474609375, 53.301461674349845]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var walespoint = /* color: #98ff00 */ee.Geometry.Point([-3.541717529296875, 53.1253499619115]);

// Spatial filtering: Extracted from https://groups.google.com/forum/#!searchin/google-earth-engine-developers/kernel$20sentinel$201$20|sort:date/google-earth-engine-developers/ExepnAmP-hQ/Xxa7raFuBAAJ
// Refined Lee speckle filter as coded in the SNAP 3.0 S1TBX:
//   https://github.com/senbox-org/s1tbx/blob/master/s1tbx-op-sar-processing/src/main/java/org/esa/s1tbx/sar/gpf/filtering/SpeckleFilters/RefinedLee.java

// Auxilliary functions
// Functions to convert from/to dB
function toNatural(img) {
  return ee.Image(10.0).pow(img.select(0).divide(10.0));
}
function toDB(img) {
  return ee.Image(img).log10().multiply(10.0);
}

// The RL speckle filter
function RefinedLee(img) {
  // img must be in natural units, i.e. not in dB!
  // Set up 3x3 kernels 
  var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
  var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);

  // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
  var sample_weights = ee.List([[0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0], [0,1,0,1,0,1,0], [0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0]]);

  var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);

  // Calculate mean and variance for the sampled windows and store as 9 bands
  var sample_mean = mean3.neighborhoodToBands(sample_kernel); 
  var sample_var = variance3.neighborhoodToBands(sample_kernel);

  // Determine the 4 gradients for the sampled windows
  var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs();
  gradients = gradients.addBands(sample_mean.select(6).subtract(sample_mean.select(2)).abs());
  gradients = gradients.addBands(sample_mean.select(3).subtract(sample_mean.select(5)).abs());
  gradients = gradients.addBands(sample_mean.select(0).subtract(sample_mean.select(8)).abs());

  // And find the maximum gradient amongst gradient bands
  var max_gradient = gradients.reduce(ee.Reducer.max());

  // Create a mask for band pixels that are the maximum gradient
  var gradmask = gradients.eq(max_gradient);

  // duplicate gradmask bands: each gradient represents 2 directions
  gradmask = gradmask.addBands(gradmask);

  // Determine the 8 directions
  var directions = sample_mean.select(1).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(7))).multiply(1);
  directions = directions.addBands(sample_mean.select(6).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(2))).multiply(2));
  directions = directions.addBands(sample_mean.select(3).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(5))).multiply(3));
  directions = directions.addBands(sample_mean.select(0).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(8))).multiply(4));
  // The next 4 are the not() of the previous 4
  directions = directions.addBands(directions.select(0).not().multiply(5));
  directions = directions.addBands(directions.select(1).not().multiply(6));
  directions = directions.addBands(directions.select(2).not().multiply(7));
  directions = directions.addBands(directions.select(3).not().multiply(8));

  // Mask all values that are not 1-8
  directions = directions.updateMask(gradmask);

  // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
  directions = directions.reduce(ee.Reducer.sum());  

  //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
  //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);

  var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean));

  // Calculate localNoiseVariance
  var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5).arrayReduce(ee.Reducer.mean(), [0]);

  // Set up the 7*7 kernels for directional statistics
  var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3).cat(ee.List.repeat(ee.List.repeat(1,7),4));

  var diag_weights = ee.List([[1,0,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,0,0,0,0], 
    [1,1,1,1,0,0,0], [1,1,1,1,1,0,0], [1,1,1,1,1,1,0], [1,1,1,1,1,1,1]]);

  var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
  var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);

  // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
  var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel).updateMask(directions.eq(1));
  var dir_var = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel).updateMask(directions.eq(1));

  dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel).updateMask(directions.eq(2)));
  dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel).updateMask(directions.eq(2)));

  // and add the bands for rotated kernels
  for (var i=1; i<4; i++) {
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
  }

  // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
  dir_mean = dir_mean.reduce(ee.Reducer.sum());
  dir_var = dir_var.reduce(ee.Reducer.sum());

  // A finally generate the filtered value
  var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV)).divide(sigmaV.add(1.0));

  var b = varX.divide(dir_var);

  var result = dir_mean.add(b.multiply(img.subtract(dir_mean)));
  return(result);
}


// Load the Sentinel-1 ImageCollection.
var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
  // Filter to get images with VV and VH dual polarization.
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  // Filter to get images collected in interferometric wide swath mode.
  .filter(ee.Filter.eq('instrumentMode', 'IW'))
  // select relative orbit number
  .filter(ee.Filter.eq('relativeOrbitNumber_start', 52))
  //select slice
  //.filter(ee.Filter.eq('sliceNumber', 5))
  // Filter time to images form 2017
  .filterDate('2016-10-01', '2017-09-30')
  // Filter to orbitdirection Descending
  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));
  //.map(toNatural)
  //.map(RefinedLee)
  //.map(toDB);
  
  
var vh = s1.select('VH').filterBounds(S1area);
var vv = s1.select('VV').filterBounds(S1area);

// Create 3 single images that can be displayed as one 3-band composite image
// Calculate the median for different times and polarisations
var comp1 = vh.filterDate('2016-10-01', '2016-10-31').median();
comp1 = ee.Image(toDB(RefinedLee(toNatural(comp1))).arrayGet([0])).multiply(100);
var comp2 = vh.filterDate('2016-11-01', '2016-11-30').median();
comp2 = ee.Image(toDB(RefinedLee(toNatural(comp2))).arrayGet([0])).multiply(100);
var comp3 = vh.filterDate('2016-12-01', '2016-12-31').median();
comp3 = ee.Image(toDB(RefinedLee(toNatural(comp3))).arrayGet([0])).multiply(100);
var comp4 = vh.filterDate('2017-01-01', '2017-01-31').median();
comp4 = ee.Image(toDB(RefinedLee(toNatural(comp4))).arrayGet([0])).multiply(100);
var comp5 = vh.filterDate('2017-02-01', '2017-02-28').median();
comp5 = ee.Image(toDB(RefinedLee(toNatural(comp5))).arrayGet([0])).multiply(100);
var comp6 = vh.filterDate('2017-03-01', '2017-03-31').median();
comp6 = ee.Image(toDB(RefinedLee(toNatural(comp6))).arrayGet([0])).multiply(100);

// From here, the layers for 12 months (delete when necessary)
var comp100 = vh.filterDate('2017-04-01', '2017-04-30').median();
comp100 = ee.Image(toDB(RefinedLee(toNatural(comp100))).arrayGet([0])).multiply(100);
var comp200 = vh.filterDate('2017-05-01', '2017-05-31').median();
comp200 = ee.Image(toDB(RefinedLee(toNatural(comp200))).arrayGet([0])).multiply(100);
var comp300 = vh.filterDate('2017-06-01', '2017-06-30').median();
comp300 = ee.Image(toDB(RefinedLee(toNatural(comp300))).arrayGet([0])).multiply(100);
var comp400 = vh.filterDate('2017-07-01', '2017-07-31').median();
comp400 = ee.Image(toDB(RefinedLee(toNatural(comp400))).arrayGet([0])).multiply(100);
var comp500 = vh.filterDate('2017-08-01', '2017-08-31').median();
comp500 = ee.Image(toDB(RefinedLee(toNatural(comp500))).arrayGet([0])).multiply(100);
var comp600 = vh.filterDate('2017-09-01', '2017-09-30').median();
comp600 = ee.Image(toDB(RefinedLee(toNatural(comp600))).arrayGet([0])).multiply(100);


var comp7 = vv.filterDate('2016-10-01', '2016-10-31').median();
comp7 = ee.Image(toDB(RefinedLee(toNatural(comp7))).arrayGet([0])).multiply(100);
var comp8 = vv.filterDate('2016-11-01', '2016-11-30').median();
comp8 = ee.Image(toDB(RefinedLee(toNatural(comp8))).arrayGet([0])).multiply(100);
var comp9 = vv.filterDate('2016-12-01', '2016-12-31').median();
comp9 = ee.Image(toDB(RefinedLee(toNatural(comp9))).arrayGet([0])).multiply(100);
var comp10 = vv.filterDate('2017-01-01', '2017-01-31').median();
comp10 = ee.Image(toDB(RefinedLee(toNatural(comp10))).arrayGet([0])).multiply(100);
var comp11 = vv.filterDate('2017-02-01', '2017-02-28').median();
comp11 = ee.Image(toDB(RefinedLee(toNatural(comp11))).arrayGet([0])).multiply(100);
var comp12 = vv.filterDate('2017-03-01', '2017-03-31').median();
comp12 = ee.Image(toDB(RefinedLee(toNatural(comp12))).arrayGet([0])).multiply(100);

// From here, the layers for 12 months (delete when necessary)
var comp700 = vv.filterDate('2017-04-01', '2017-04-30').median();
comp700 = ee.Image(toDB(RefinedLee(toNatural(comp700))).arrayGet([0])).multiply(100);
var comp800 = vv.filterDate('2017-05-01', '2017-05-31').median();
comp800 = ee.Image(toDB(RefinedLee(toNatural(comp800))).arrayGet([0])).multiply(100);
var comp900 = vv.filterDate('2017-06-01', '2017-06-30').median();
comp900 = ee.Image(toDB(RefinedLee(toNatural(comp900))).arrayGet([0])).multiply(100);
var comp1000 = vv.filterDate('2017-07-01', '2017-07-31').median();
comp1000 = ee.Image(toDB(RefinedLee(toNatural(comp1000))).arrayGet([0])).multiply(100);
var comp1100 = vv.filterDate('2017-08-01', '2017-08-31').median();
comp1100 = ee.Image(toDB(RefinedLee(toNatural(comp1100))).arrayGet([0])).multiply(100);
var comp1200 = vv.filterDate('2017-09-01', '2017-09-30').median();
comp1200 = ee.Image(toDB(RefinedLee(toNatural(comp1200))).arrayGet([0])).multiply(100);

// Bands for (VV-VH) (see Abdikan et al. 2016)
var comp13 = comp7.subtract(comp1);
var comp14 = comp8.subtract(comp2);
var comp15 = comp9.subtract(comp3);
var comp16 = comp10.subtract(comp4);
var comp17 = comp11.subtract(comp5);
var comp18 = comp12.subtract(comp6);

var comp1300 = comp700.subtract(comp100);
var comp1400 = comp800.subtract(comp200);
var comp1500 = comp900.subtract(comp300);
var comp1600 = comp1000.subtract(comp400);
var comp1700 = comp1100.subtract(comp500);
var comp1800 = comp1200.subtract(comp600);

//Map.addLayer(comp13, {min: [-3500], max: [-100]}, 'singleS1');

// merge the 3-bands as single composite
var s1_composite = comp1.addBands(comp2).addBands(comp3).addBands(comp4).addBands(comp7).addBands(comp8).addBands(comp9).addBands(comp10).addBands(comp13).addBands(comp14).addBands(comp15).addBands(comp16);



////////////////////////////////////////
// Cloud masking algorithm for Sentinel2
//METHOD 1: Built on ideas from Landsat cloudScore algorithm
//Currently in beta and may need tweaking for individual study areas
var rescale = function(img, exp, thresholds) {
    return img.expression(exp, {img: img})
        .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
  };
  
function sentinelCloudScore(img) {
  
  // Compute several indicators of cloudyness and take the minimum of them.
  var score = ee.Image(1);
    // Clouds are reasonably bright in the blue and cirrus bands.
  score = score.min(rescale(img, 'img.B2', [0.1, 0.5]));
  score = score.min(rescale(img, 'img.B1', [0.1, 0.3]));
  score = score.min(rescale(img, 'img.B1 + img.B10', [0.15, 0.2]));
    // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(img, 'img.B4 + img.B3 + img.B2', [0.2, 0.8]));
  //Clouds are moist
  var ndmi = img.normalizedDifference(['B8','B11']);
  score=score.min(rescale(ndmi, 'img', [-0.1, 0.1]));
    // However, clouds are not snow.
  var ndsi = img.normalizedDifference(['B3', 'B11']);
  score=score.min(rescale(ndsi, 'img', [0.8, 0.6]));
    score = score.multiply(100).byte();
 
  return img.addBands(score.rename('cloudScore'));
}
//////////////////////////////////////////////////////////////////////////

// METHOD 2: Function to mask clouds using the Sentinel-2 QA band.
function maskS2clouds(image) {
  var qa = image.select('QA60');
  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = Math.pow(2, 10);
  var cirrusBitMask = Math.pow(2, 11);
  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0).and(
             qa.bitwiseAnd(cirrusBitMask).eq(0));
  // Return the masked and scaled data.
  return image.updateMask(mask);
}

// Load S2 1-C input imagery.
var S2_spr = ee.ImageCollection('COPERNICUS/S2')
  // Filter to get only one year of images.
  .filterDate('2016-10-01', '2017-03-31')
  // Filter to get only images under the region of interest.
  //.filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.eq('WRS_ROW', 23))
  // Sentinel cloud mask is less selective than Landsat, so some people pre filter by relatively cloud free images
  //.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .filterBounds(S1area)
  //CLOUD METHOD2
  .map(maskS2clouds)
  //CLOUD METHOD 1
  //.map(function bustClouds(img){
  //img = sentinelCloudScore(img);
  //img = img.updateMask(img.select(['cloudScore']).gt(cloudThresh).focal_min(contractPixels).focal_max(dilatePixels).not());
  //return img
  //})
  .select(['B2', 'B3','B4', 'B5', 'B6','B7','B8','B11','B12']);
  
var S2_win = ee.ImageCollection('COPERNICUS/S2')
  // Filter to get only one year of images.
  .filterDate('2017-04-01', '2017-09-30')
  .filterBounds(S1area)
  //CLOUD METHOD 2
  .map(maskS2clouds)
  .select(['B2', 'B3','B4', 'B5', 'B6','B7','B8','B11','B12']);

// For the case of extracting the S2 data into 10m, we need resample in bilinear:
var S2_spr_median = S2_spr.median()//.clip(landsat.geometry());//.reproject('EPSG:4326',null,30);
//S2_spr_median = S2_spr_median.resample('bilinear');
var S2_win_median = S2_win.median();
//S2_win_median = S2_win_median.resample('bilinear');
var S2_spr_var = S2_spr.reduce(ee.Reducer.variance()).divide(1000);
var S2_win_var = S2_win.reduce(ee.Reducer.variance()).divide(1000);
print(ee.Image(S2_spr_median.projection()));



// Load Landsat 5 input imagery.
//var landsat1 = ee.Image(ee.ImageCollection('LANDSAT/LC08/C01/T1')
var landsat_spr = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
  // Filter to get only one year of images.
  .filterDate('2016-10-01', '2017-03-31')
  // Filter to get only images under the region of interest.
  .filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.rangeContains("PATH", 23, 24))
  .filterBounds(S2_spr.geometry())
  .map(function(img){
    var mask = img.select(['pixel_qa']).bitwiseAnd(32).eq(0)
    return img.updateMask(mask)
    })
  .select(['B1', 'B2', 'B3','B4', 'B5', 'B6','B7']);
  
var landsat_win = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
  // Filter to get only one year of images.
  .filterDate('2017-04-01', '2017-09-30')
  // Filter to get only images under the region of interest.
  .filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.rangeContains("PATH", 23, 24))
  .filterBounds(S2_spr.geometry())
  .map(function(img){
    var mask = img.select(['pixel_qa']).bitwiseAnd(32).eq(0)
    return img.updateMask(mask)
    })
  .select(['B1', 'B2', 'B3','B4', 'B5', 'B6','B7']);

var lan = ee.Image(landsat_spr.first())
//Map.addLayer(lan, {bands: ['B5', 'B4', 'B3']}, 'lan');

var landsat_spr_median = landsat_spr.median();
var landsat_win_median = landsat_win.median();

var landsat_spr_var = landsat_spr.reduce(ee.Reducer.variance()).divide(100);
var landsat_win_var = landsat_win.reduce(ee.Reducer.variance()).divide(100);


var dataset = landsat_spr_median.addBands(landsat_win_median).addBands(S2_spr_median).addBands(S2_win_median)
.addBands(comp1).addBands(comp2).addBands(comp3).addBands(comp4).addBands(comp5).addBands(comp6).addBands(comp7).addBands(comp8).addBands(comp9).addBands(comp10).addBands(comp11).addBands(comp12)
.addBands(comp100).addBands(comp200).addBands(comp300).addBands(comp400).addBands(comp500).addBands(comp600).addBands(comp700).addBands(comp800).addBands(comp900).addBands(comp1000).addBands(comp1100).addBands(comp1200)
.addBands(comp13).addBands(comp14).addBands(comp15).addBands(comp16).addBands(comp17).addBands(comp18).addBands(comp1300).addBands(comp1400).addBands(comp1500).addBands(comp1600).addBands(comp1700).addBands(comp1800);



Map.addLayer(dataset, {bands: ['B4', 'B3', 'B2'],min:0,max:3000}, 'dataset_lan');


Export.image.toDrive({
  image: dataset.clip(S2_spr.geometry()).int16(),
  //region: S2_spr.geometry().bounds(),
  description: 'p42',
  scale: 30,
  crs : 'EPSG:27700',
  // Dimensions for 30m scale
  dimensions:"399960x5690220",
  // Max pixels for 30m scale
  maxPixels: 399960*5690220
 
});





Map.centerObject(walespoint, 8);
//Map.addLayer(s1_composite, {min: [-20, -20, -15], max: [-6, -6, 0]}, 's1_composite');
//Map.addLayer(S2_spr, {bands: ['B5', 'B4', 'B3'],min:0,max:3000}, 'S2');
//Map.addLayer(ndvi_mean,{palette: palette, min:-1, max: 1},'ndvi_mean');
//Map.addLayer(trainingraster,{palette: palette, min: 1, max: 23})
//Map.addLayer(classified, {palette: palette, min: 1, max: 23}, 'classification');
//Export.image.toDrive({
//  image: classified,
//    region: S2_spr.geometry(),
//    description: 'wales_classification_S1fourseasons_L8S2_twoseasons',
//    scale: 30,
//    maxPixels: 298452024
//    //region: geometry
//});
