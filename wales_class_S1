/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var S1area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-4.25994873046875, 52.97847790594886],
          [-3.97979736328125, 51.90875993271863],
          [-3.5322682632632905, 51.93943160087239],
          [-3.3887907575058307, 51.968055159146736],
          [-3.28765869140625, 52.125120950434145],
          [-3.07891845703125, 52.908964224129605],
          [-3.47991943359375, 53.00988788760457],
          [-3.73809814453125, 52.980131632468]]]),
    test_area = /* color: #98ff00 */ee.Geometry.Polygon(
        [[[-3.6199951171875, 53.248905518153315],
          [-3.5540771484375, 53.265336258629475],
          [-3.5540771484375, 53.30802665091056],
          [-3.636474609375, 53.301461674349845]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
var walespoint = /* color: #98ff00 */ee.Geometry.Point([-3.541717529296875, 53.1253499619115]);

//Parameters for cloud masking functions
var cloudThresh =20;//Ranges from 1-100.Lower value will mask more pixels out. Generally 10-30 works well with 20 being used most commonly 
var dilatePixels = 2; //Pixels to dilate around clouds
var contractPixels = 1;//Pixels to reduce cloud mask and dark shadows by to reduce inclusion of single-pixel comission errors

// Load the Sentinel-1 ImageCollection.
var s1_2016 = ee.ImageCollection('COPERNICUS/S1_GRD')
  // Filter to get images with VV and VH dual polarization.
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  // Filter to get images collected in interferometric wide swath mode.
  .filter(ee.Filter.eq('instrumentMode', 'IW'))
  // select relative orbit number
  .filter(ee.Filter.eq('relativeOrbitNumber_start', 52))
  //select slice
  //.filter(ee.Filter.eq('sliceNumber', 5))
  // Filter time to images form 2017
  .filterDate('2016-01-01', '2016-12-31')
  // Filter to orbitdirection Descending
  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));
  
  
var vh = s1_2016.select('VH').filterBounds(S1area);
var vv = s1_2016.select('VV').filterBounds(S1area);

// Create 3 single images that can be displayed as one 3-band composite image
// Calculate the median for different times and polarisations
var comp1 = vh.filterDate('2016-01-01', '2016-03-31').median();
var comp2 = vh.filterDate('2016-04-01', '2016-06-30').median();
var comp3 = vh.filterDate('2016-07-01', '2016-09-30').median();
var comp4 = vh.filterDate('2016-10-01', '2016-12-31').median();
//var comp5 = vh.filterDate('2016-09-01', '2016-10-30').median();
//var comp6 = vh.filterDate('2016-11-01', '2016-12-30').median();
var comp7 = vv.filterDate('2016-01-01', '2016-03-31').median();
var comp8 = vv.filterDate('2016-04-01', '2016-06-30').median();
var comp9 = vv.filterDate('2016-07-01', '2016-09-30').median();
var comp10 = vv.filterDate('2016-10-01', '2016-12-31').median();
//var comp11 = vv.filterDate('2016-09-01', '2016-10-30').median();
//var comp12 = vv.filterDate('2016-11-01', '2016-12-30').median();


// merge the 3-bands as single composite
var s1_composite = ee.Image.cat ([comp1,comp2,comp3,comp4,comp7,comp8,comp9,comp10]).focal_median();


////////////////////////////////////////
// Cloud masking algorithm for Sentinel2
//METHOD 1: Built on ideas from Landsat cloudScore algorithm
//Currently in beta and may need tweaking for individual study areas
var rescale = function(img, exp, thresholds) {
    return img.expression(exp, {img: img})
        .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
  };
  
function sentinelCloudScore(img) {
  
  // Compute several indicators of cloudyness and take the minimum of them.
  var score = ee.Image(1);
  
  // Clouds are reasonably bright in the blue and cirrus bands.
  score = score.min(rescale(img, 'img.B2', [0.1, 0.5]));
  score = score.min(rescale(img, 'img.B1', [0.1, 0.3]));
  score = score.min(rescale(img, 'img.B1 + img.B10', [0.15, 0.2]));
  
  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(img, 'img.B4 + img.B3 + img.B2', [0.2, 0.8]));

  //Clouds are moist
  var ndmi = img.normalizedDifference(['B8','B11']);
  score=score.min(rescale(ndmi, 'img', [-0.1, 0.1]));
  
  // However, clouds are not snow.
  var ndsi = img.normalizedDifference(['B3', 'B11']);
  score=score.min(rescale(ndsi, 'img', [0.8, 0.6]));
  
  score = score.multiply(100).byte();
 
  return img.addBands(score.rename('cloudScore'));
}
//////////////////////////////////////////////////////////////////////////

// METHOD 2: Function to mask clouds using the Sentinel-2 QA band.
function maskS2clouds(image) {
  var qa = image.select('QA60');
  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = Math.pow(2, 10);
  var cirrusBitMask = Math.pow(2, 11);
  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0).and(
             qa.bitwiseAnd(cirrusBitMask).eq(0));
  // Return the masked and scaled data.
  return image.updateMask(mask);
}

// Load S2 1-C input imagery.
var S2_spr = ee.ImageCollection('COPERNICUS/S2')
  // Filter to get only one year of images.
  .filterDate('2017-04-01', '2017-07-31')
  // Filter to get only images under the region of interest.
  //.filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.eq('WRS_ROW', 23))
  // Sentinel cloud mask is less selective than Landsat, so some people pre filter by relatively cloud free images
  //.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .filterBounds(S1area)
  //CLOUD METHOD2
  //.map(maskS2clouds)
  //CLOUD METHOD 1
  .map(function bustClouds(img){
  img = sentinelCloudScore(img);
  img = img.updateMask(img.select(['cloudScore']).gt(cloudThresh).focal_min(contractPixels).focal_max(dilatePixels).not());
  return img
  })
  .select(['B2', 'B3','B4', 'B5', 'B6','B7','B8','B11','B12']);
  
var S2_win = ee.ImageCollection('COPERNICUS/S2')
  // Filter to get only one year of images.
  .filterDate('2016-10-01', '2017-02-28')
  // Filter to get only images under the region of interest.
  //.filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.eq('WRS_ROW', 23))
  // Sentinel cloud mask is less selective than Landsat, so some people pre filter by relatively cloud free images
  //.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .filterBounds(S1area)
  //CLOUD METHOD 2
  //.map(maskS2clouds)
  //CLOUD METHOD 1
  .map(function bustClouds(img){
  img = sentinelCloudScore(img);
  img = img.updateMask(img.select(['cloudScore']).gt(cloudThresh).focal_min(contractPixels).focal_max(dilatePixels).not());
  return img
  })
  
  .select(['B2', 'B3','B4', 'B5', 'B6','B7','B8','B11','B12']);


var S2_spr_median = S2_spr.median()//.clip(landsat.geometry());//.reproject('EPSG:4326',null,30);
var S2_win_median = S2_win.median();


// Load Landsat 5 input imagery.
//var landsat1 = ee.Image(ee.ImageCollection('LANDSAT/LC08/C01/T1')
var landsat_spr = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
  // Filter to get only one year of images.
  .filterDate('2017-04-01', '2017-07-31')
  // Filter to get only images under the region of interest.
  .filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.rangeContains("PATH", 23, 24))
  .filterBounds(S2_spr.geometry())
  .map(function(img){
    var mask = img.select(['pixel_qa']).bitwiseAnd(32).eq(0)
    return img.updateMask(mask)
    })
  .select(['B1', 'B2', 'B3','B4', 'B5', 'B6','B7']);
  
var landsat_win = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
  // Filter to get only one year of images.
  .filterDate('2016-10-01', '2017-02-28')
  // Filter to get only images under the region of interest.
  .filter(ee.Filter.eq('WRS_PATH', 204))
  //.filter(ee.Filter.rangeContains("PATH", 23, 24))
  .filterBounds(S2_spr.geometry())
  .map(function(img){
    var mask = img.select(['pixel_qa']).bitwiseAnd(32).eq(0)
    return img.updateMask(mask)
    })
  .select(['B1', 'B2', 'B3','B4', 'B5', 'B6','B7']);

var lan = ee.Image(landsat_spr.first())
//Map.addLayer(lan, {bands: ['B5', 'B4', 'B3']}, 'lan');

var landsat_spr_median = landsat_spr.median();//.clip(landsat.geometry());//.reproject('EPSG:4326',null,30);
var landsat_win_median = landsat_win.median();

//var landsat_spr_var = landsat_spr.reduce(ee.Reducer.variance()).divide(100);




// Elevation layer
var dem = ee.Image('USGS/SRTMGL1_003').clip(S2_spr.geometry())//.reproject(proj);

// Distance to sea layer
var distsea = ee.Image('users/luiscartor/distsea').int().clip(S2_spr.geometry())//.reproject(proj);

// Classification training data
var trainingraster = ee.Image('users/luiscartor/wales_c35training_NAs').int();

print(ee.Image(landsat_spr_median.clip(S2_spr.geometry())).arrayDimensions());
print(ee.Image(landsat_spr_median.projection()));


// Extract dataset
var dataset = S2_spr_median.clip(S2_spr.geometry()).addBands(S2_win_median).clip(S2_spr.geometry());
Map.addLayer(dataset, {bands: ['B5', 'B4', 'B3'],min:0,max:3000}, 'dataset');
Export.image.toDrive({
  image: dataset.int16(),
    //region: S2_spr.geometry(),
    description: 'p22',
    dimensions:"399960x5690220",
    scale: 30,
    maxPixels: 399960*5690220
    //region: geometry
});


// Extract dataset
var dataset2 = s1_composite.addBands(S2_spr_median).addBands(S2_win_median).addBands(landsat_spr_median.clip(S2_spr.geometry())).addBands(landsat_win_median.clip(S2_spr.geometry()))
//Map.addLayer(dataset2, {bands: ['B5', 'B4', 'B3']}, 'dataset2');
Export.image.toDrive({
  image: dataset2.float(),
    //region: S2_spr.geometry(),
    crs : 'EPSG:4326',
    crsTransform : [1,0,0,0,1,0],
    description: 'composite_all',
    dimensions:"399960x5690220",
    //scale: 30,
    maxPixels: 399960*5690220
});


//Training using sample regions to sample 10000 for each class
var training = s1_composite.addBands(S2_spr_median).addBands(S2_win_median).addBands(landsat_spr_median).addBands(landsat_win_median).addBands(dem).addBands(distsea).addBands(trainingraster).stratifiedSample({
  numPoints: 4000,
  classBand: 'b1_1',
  region: S2_spr.geometry(),
  seed:0,
  scale:30,
  projection: 'EPSG:4326',
  //tileScale: 4
});
Export.table.toDrive(training,'S1S2L8training')

// Make a Random Forest classifier and train it.
var classifier = ee.Classifier.randomForest(30)
    .train(training, 'b1_1');

Export.table.toDrive(ee.FeatureCollection(ee.Feature(null, {'matrix': classifier.confusionMatrix()})));


// Classify the input imagery.
var classified =  s1_composite.clip(S2_spr.geometry()).addBands(S2_spr_median).addBands(S2_win_median).addBands(landsat_spr_median.clip(S2_spr.geometry())).addBands(landsat_win_median.clip(S2_spr.geometry())).addBands(dem).addBands(distsea).classify(classifier);

//Sample used for validation
var testsample =  s1_composite.addBands(S2_spr_median).addBands(S2_win_median).addBands(landsat_spr_median).addBands(landsat_win_median).addBands(dem).addBands(distsea).addBands(trainingraster).stratifiedSample({
  numPoints: 100,
  region: S2_spr.geometry(), //If region not specified: issues with projections!
  classBand: 'b1_1',
  seed:1, // Different seed from training sample
  scale:30,
  projection: 'EPSG:4326',
  //tileScale: 4
}).filter(ee.Filter.neq('b1_1', null)); // Filter the result to get rid of any null pixels.


// Accuracy assessment
//print(testsample)
var trainAccuracy = testsample.classify(classifier).errorMatrix('b1_1', 'classification');
print('Resubstitution error matrix: ', trainAccuracy);
print('Training overall accuracy: ', trainAccuracy.accuracy());
print('Training kappa: ', trainAccuracy.kappa());


// Define a palette for the classification.
var palette = [
  //'FFFFFF', // non
  'ff0000', // broadleaved f
  '008000', // evergreen
  '8b4513', // arable
  '7CFC00', // improved
  'FFA500', // rough
  '66CDAA', // neutral
  '2E8B57', // calcareous
  '808000', // acid
  'FFFF00', // fen
  '800080', // heather
  'EE82EE', // heather grassland
  '008080', // bog
  '40E0D0', // montaine
  'B0C4DE', // bare rock
  '00008B', // sea
  '0000FF', // water
  'B8860B', // supra
  'B8860B', // supra
  'F0E68C', // litoral
  'F0E68C', // litoral
  '9370DB', // marsh
  '000000', // urban
  'A9A9A9', // semi urban
];

Map.centerObject(walespoint, 8);
//Map.addLayer(s1_composite, {min: [-20, -20, -15], max: [-6, -6, 0]}, 's1_composite');
Map.addLayer(S2_spr, {bands: ['B5', 'B4', 'B3'],min:0,max:3000}, 'S2');
//Map.addLayer(ndvi_mean,{palette: palette, min:-1, max: 1},'ndvi_mean');
//Map.addLayer(trainingraster,{palette: palette, min: 1, max: 23})
//Map.addLayer(classified, {palette: palette, min: 1, max: 23}, 'classification');
//Export.image.toDrive({
//  image: classified,
//    region: S2_spr.geometry(),
//    description: 'wales_classification_S1fourseasons_L8S2_twoseasons',
//    scale: 30,
//    maxPixels: 298452024
//    //region: geometry
//});
